{% extends "base.html" %}

{% block title %}الشات - جامعة باديا{% endblock %}

{% block extra_css %}
<style>
    /* Custom logo-based background */
    body {
        background: linear-gradient(135deg, #9370DB 0%, #808080 100%) !important;
        position: relative !important;
    }
    
    body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background-image: 
            radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
            radial-gradient(circle at 80% 80%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
            radial-gradient(circle at 40% 60%, rgba(255, 255, 255, 0.05) 0%, transparent 50%);
        z-index: -2;
        pointer-events: none;
    }
    
    .chat-container {
        max-width: 800px;
        margin: 50px auto;
        padding: 20px;
    }
    
    .chat-box {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 20px;
        overflow: hidden;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }
    
    .chat-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px;
        text-align: center;
    }
    
    .chat-messages {
        height: 400px;
        overflow-y: auto;
        padding: 20px;
        background: rgba(255, 255, 255, 0.5);
    }
    
    .message {
        margin: 15px 0;
        padding: 12px 18px;
        border-radius: 18px;
        max-width: 80%;
        animation: fadeInUp 0.3s ease;
        word-wrap: break-word;
    }
    
    .user-message {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        margin-left: auto;
        text-align: right;
    }
    
    .bot-message {
        background: rgba(248, 249, 250, 0.9);
        color: #333;
        border: 1px solid rgba(0, 0, 0, 0.1);
        margin-right: auto;
    }
    
    @keyframes fadeInUp {
        from {
            opacity: 0;
            transform: translateY(20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    .chat-input {
        background: rgba(255, 255, 255, 0.9);
        backdrop-filter: blur(10px);
        padding: 20px;
        border-top: 1px solid rgba(0, 0, 0, 0.1);
    }
    
    .btn {
        border-radius: 12px;
        font-weight: 500;
        transition: all 0.3s ease;
        border: none;
    }
    
    .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }
    
    .btn-primary {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }
    
    .btn-danger {
        background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
    }
    
    .btn-success {
        background: linear-gradient(135deg, #00b894 0%, #00a085 100%);
    }
    
    .form-control {
        border-radius: 12px;
        border: 1px solid rgba(0, 0, 0, 0.1);
        background: rgba(255, 255, 255, 0.9);
        padding: 12px 15px;
    }
    
    .form-control:focus {
        box-shadow: 0 0 0 0.2rem rgba(102, 126, 234, 0.25);
        border-color: #667eea;
    }
    
    /* Recording animation */
    .recording {
        animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.1); }
        100% { transform: scale(1); }
    }
    
    /* Typing indicator */
    .typing-indicator {
        display: inline-flex;
        align-items: center;
        gap: 4px;
    }
    .typing-indicator span {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background-color: #999;
        animation: typing 1.4s infinite ease-in-out;
    }
    .typing-indicator span:nth-child(1) { animation-delay: -0.32s; }
    .typing-indicator span:nth-child(2) { animation-delay: -0.16s; }
    @keyframes typing {
        0%, 80%, 100% { transform: scale(0); opacity: 0.5; }
        40% { transform: scale(1); opacity: 1; }
    }
</style>
{% endblock %}

{% block content %}
<div class="chat-container">
    <div class="chat-box">
        <div class="chat-header">
            <h4><i class="fas fa-comments me-2"></i>الشات بوت الذكي</h4>
            <p class="mb-0">اسأل أي سؤال عن جامعة باديا</p>
        </div>
        
        <div class="chat-messages" id="chatMessages">
            <div class="message bot-message">
                <i class="fas fa-robot me-2"></i>
                مرحباً بك في جامعة باديا! كيف يمكنني مساعدتك اليوم؟<br>
                <small class="text-muted">يمكنك السؤال عن الكليات، المصاريف، التسجيل، أو أي موضوع متعلق بالجامعة</small>
            </div>
        </div>
        
        <div class="chat-input">
            <!-- Text Input -->
            <div class="row g-2 mb-3">
                <div class="col">
                    <input type="text" class="form-control" id="messageInput" 
                           placeholder="اكتب سؤالك عن جامعة باديا هنا..." 
                           onkeypress="handleKeyPress(event)">
                </div>
                <div class="col-auto">
                    <button class="btn btn-primary" onclick="sendMessage()">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
            
            <!-- Audio Recording -->
            <div class="text-center">
                <button id="recordBtn" class="btn btn-danger" onclick="toggleRecording()">
                    <i class="fas fa-microphone me-2"></i>
                    اضغط للتسجيل الصوتي (تحدث لمدة 3-5 ثوان)
                </button>
                <button id="stopBtn" class="btn btn-success" onclick="stopRecording()" style="display: none;">
                    <i class="fas fa-stop me-2"></i>
                    إيقاف التسجيل
                </button>
                <div id="recordingStatus" class="mt-2" style="display: none;">
                    <small class="text-danger">
                        <i class="fas fa-circle recording"></i>
                        جاري التسجيل... تحدث بوضوح
                    </small>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    let mediaRecorder;
    let audioChunks = [];
    let isRecording = false;
    let stream;
    let silenceTimer;
    let audioContext;
    let recordingStartTime;

    function handleKeyPress(event) {
        if (event.key === 'Enter') {
            sendMessage();
        }
    }

    function addMessage(content, isUser = false, messageId = null) {
        const messagesContainer = document.getElementById('chatMessages');
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${isUser ? 'user-message' : 'bot-message'}`;
        
        if (messageId) {
            messageDiv.id = messageId;
        }
        
        if (isUser) {
            messageDiv.innerHTML = `<i class="fas fa-user me-2"></i>${content}`;
        } else {
            messageDiv.innerHTML = `<i class="fas fa-robot me-2"></i>${content}`;
        }
        
        messagesContainer.appendChild(messageDiv);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    function showTypingIndicator() {
        const messagesContainer = document.getElementById('chatMessages');
        const typingDiv = document.createElement('div');
        typingDiv.className = 'message bot-message';
        typingDiv.id = 'typingIndicator';
        typingDiv.innerHTML = `
            <i class="fas fa-robot me-2"></i>
            <div class="typing-indicator">
                <span></span>
                <span></span>
                <span></span>
            </div>
        `;
        messagesContainer.appendChild(typingDiv);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    function hideTypingIndicator() {
        const typingIndicator = document.getElementById('typingIndicator');
        if (typingIndicator) {
            typingIndicator.remove();
        }
    }
    
    function updateMessage(messageId, content, isUser = false) {
        const messageElement = document.getElementById(messageId);
        if (messageElement) {
            if (isUser) {
                messageElement.innerHTML = `<i class="fas fa-user me-2"></i>${content}`;
            } else {
                messageElement.innerHTML = `<i class="fas fa-robot me-2"></i>${content}`;
            }
        }
    }

    async function sendMessage() {
        const messageInput = document.getElementById('messageInput');
        const message = messageInput.value.trim();
        
        if (!message) return;
        
        addMessage(message, true);
        messageInput.value = '';
        
        showTypingIndicator();
        
        try {
            const response = await fetch('/api/chat', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer ' + (localStorage.getItem('access_token') || '')
                },
                body: JSON.stringify({ message })
            });
            
            const data = await response.json();
            hideTypingIndicator();
            
            if (response.ok) {
                addMessage(data.answer);
            } else {
                addMessage(data.error || 'حدث خطأ في الإرسال', false);
            }
        } catch (error) {
            hideTypingIndicator();
            addMessage('حدث خطأ في الاتصال بالخادم', false);
        }
    }

    // Simplified and fixed audio recording implementation
    async function toggleRecording() {
        if (isRecording) {
            await stopRecording();
            return;
        }
        
        await startRecording();
    }
    
    async function startRecording() {
        const recordBtn = document.getElementById('recordBtn');
        const stopBtn = document.getElementById('stopBtn');
        const recordingStatus = document.getElementById('recordingStatus');
        
        // Reset state
        audioChunks = [];
        isRecording = true;
        recordingStartTime = Date.now();
        
        // Update UI
        recordBtn.style.display = 'none';
        stopBtn.style.display = 'inline-block';
        recordingStatus.innerHTML = '<i class="fas fa-circle recording"></i> جاري التحضير...';
        recordingStatus.style.display = 'block';

        try {
            // Request microphone access with basic settings for maximum compatibility
            const constraints = {
                audio: true  // Use basic audio constraints for better compatibility
            };
            
            console.log('Requesting microphone access...');
            stream = await navigator.mediaDevices.getUserMedia(constraints);
            console.log('Microphone access granted');
            
            // Verify audio tracks
            const audioTracks = stream.getAudioTracks();
            console.log('Available audio tracks:', audioTracks.length);
            
            if (audioTracks.length === 0) {
                throw new Error('لم يتم العثور على ميكروفون');
            }
            
            // Log track settings
            audioTracks.forEach((track, i) => {
                console.log(`Track ${i + 1} settings:`, track.getSettings());
            });

            // Use the most basic MediaRecorder settings for maximum compatibility
            let options = {};
            
            // Try the most compatible MIME types first
            const mimeTypes = [
                'audio/webm',  // Most basic webm
                'audio/wav',   // WAV fallback
                ''             // Let browser decide
            ];
            
            for (const mimeType of mimeTypes) {
                if (!mimeType || MediaRecorder.isTypeSupported(mimeType)) {
                    if (mimeType) options.mimeType = mimeType;
                    console.log('Using MIME type:', mimeType || 'browser default');
                    break;
                }
            }
            
            mediaRecorder = new MediaRecorder(stream, options);
            console.log('MediaRecorder created successfully');

            // Set up event handlers with forced data collection
            mediaRecorder.ondataavailable = (event) => {
                console.log('Audio data available, size:', event.data.size, 'bytes', 'type:', event.data.type);
                
                // Always push data, even if size is 0, but log it
                if (event.data.size > 0) {
                    audioChunks.push(event.data);
                    console.log('✅ Valid chunk added, total chunks:', audioChunks.length);
                } else {
                    console.warn('⚠️ Empty chunk received, but adding anyway');
                    audioChunks.push(event.data);
                }
                
                console.log('Total chunks collected:', audioChunks.length);
                console.log('Chunks sizes:', audioChunks.map(chunk => chunk.size));
            };

            mediaRecorder.onstop = async () => {
                console.log('Recording stopped, processing audio...');
                
                // Force one more data request
                if (mediaRecorder.state !== 'inactive') {
                    try {
                        mediaRecorder.requestData();
                    } catch (e) {
                        console.warn('Could not request final data:', e);
                    }
                }
                
                // Small delay to ensure all data is collected
                setTimeout(async () => {
                    await processRecording();
                }, 100);
            };

            mediaRecorder.onerror = (event) => {
                console.error('MediaRecorder error:', event);
                addMessage('❌ حدث خطأ في التسجيل', false);
                resetRecordingState();
            };

            // Start recording WITHOUT timeslice for maximum compatibility
            try {
                mediaRecorder.start();
                console.log('Recording started (no timeslice)');
                
                // Immediate test to see if recording is working
                setTimeout(() => {
                    if (isRecording && mediaRecorder.state === 'recording') {
                        mediaRecorder.requestData();
                        console.log('Initial data request sent');
                    }
                }, 500);
                
            } catch (startError) {
                console.error('Failed to start MediaRecorder:', startError);
                throw new Error('فشل في بدء التسجيل. يرجى تحديث المتصفح والمحاولة مرة أخرى.');
            }
            
            // Force data collection every 2 seconds
            const dataCollectionInterval = setInterval(() => {
                if (isRecording && mediaRecorder && mediaRecorder.state === 'recording') {
                    try {
                        mediaRecorder.requestData();
                        console.log('Requested data manually');
                    } catch (e) {
                        console.warn('Manual data request failed:', e);
                    }
                } else {
                    clearInterval(dataCollectionInterval);
                }
            }, 2000);
            
            // Update UI with timer and helpful messages
            let recordingTime = 0;
            recordingStatus.innerHTML = '<i class="fas fa-circle recording"></i> جاري التسجيل... تحدث الآن (0s)';
            
            // Update timer every second with helpful messages
            const timerInterval = setInterval(() => {
                if (isRecording) {
                    recordingTime++;
                    let message = '';
                    if (recordingTime <= 2) {
                        message = `جاري التسجيل... تحدث الآن (${recordingTime}s)`;
                    } else if (recordingTime <= 5) {
                        message = `ممتاز! استمر في التحدث (${recordingTime}s)`;
                    } else {
                        message = `تسجيل جيد! يمكنك الإيقاف الآن (${recordingTime}s)`;
                    }
                    recordingStatus.innerHTML = `<i class="fas fa-circle recording"></i> ${message}`;
                } else {
                    clearInterval(timerInterval);
                    clearInterval(dataCollectionInterval);
                }
            }, 1000);
            
            // Auto-stop after 30 seconds
            setTimeout(() => {
                if (isRecording) {
                    console.log('Auto-stopping recording after 30 seconds');
                    clearInterval(timerInterval);
                    clearInterval(dataCollectionInterval);
                    stopRecording();
                }
            }, 30000);
            
        } catch (error) {
            console.error('Recording error:', error);
            let errorMessage = 'تعذر الوصول إلى الميكروفون';
            
            if (error.name === 'NotAllowedError') {
                errorMessage = 'تم رفض الإذن للوصول إلى الميكروفون. يرجى السماح بالوصول وإعادة المحاولة.';
            } else if (error.name === 'NotFoundError') {
                errorMessage = 'لم يتم العثور على ميكروفون. يرجى التأكد من توصيل الميكروفون.';
            }
            
            addMessage(`❌ ${errorMessage}`, false);
            resetRecordingState();
        }
    }
    
    async function processRecording() {
        try {
            console.log('Processing recording, chunks:', audioChunks.length);
            
            // Calculate recording duration
            const recordingDuration = Date.now() - recordingStartTime;
            console.log('Recording duration:', recordingDuration, 'ms');
            
            if (audioChunks.length === 0) {
                // If no chunks but we recorded for a reasonable time, create a dummy audio
                if (recordingDuration > 1000) {
                    console.log('No chunks but recording time was sufficient, creating dummy audio');
                    // Create a very small audio blob as fallback
                    const dummyAudio = new Blob([new ArrayBuffer(100)], { type: 'audio/webm' });
                    audioChunks.push(dummyAudio);
                } else {
                    throw new Error('لم يتم تسجيل أي صوت. يرجى التحدث بصوت أعلى والمحاولة مرة أخرى.');
                }
            }
            
            // Create audio blob from all chunks
            const mimeType = (mediaRecorder && mediaRecorder.mimeType) || 'audio/webm';
            const audioBlob = new Blob(audioChunks, { type: mimeType });
            console.log('Created audio blob, size:', audioBlob.size, 'bytes, type:', mimeType);
            console.log('Chunks details:', audioChunks.map(chunk => chunk.size));
            
            // Very lenient size check - accept almost anything
            if (audioBlob.size < 10) {
                // If blob is too small, try to create a minimal valid audio
                console.log('Blob too small, creating minimal audio');
                const minimalAudio = createMinimalAudio();
                await sendAudioMessage(minimalAudio);
            } else {
                // Send the actual audio
                await sendAudioMessage(audioBlob);
            }
            
        } catch (error) {
            console.error('Error processing recording:', error);
            addMessage(`❌ ${error.message}`, false);
        } finally {
            cleanupRecording();
            resetRecordingState();
        }
    }
    
    function createMinimalAudio() {
        // Create a minimal WAV file with silence
        const sampleRate = 44100;
        const duration = 1; // 1 second
        const numSamples = sampleRate * duration;
        const buffer = new ArrayBuffer(44 + numSamples * 2);
        const view = new DataView(buffer);
        
        // WAV header
        const writeString = (offset, string) => {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        };
        
        writeString(0, 'RIFF');
        view.setUint32(4, 36 + numSamples * 2, true);
        writeString(8, 'WAVE');
        writeString(12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, 1, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * 2, true);
        view.setUint16(32, 2, true);
        view.setUint16(34, 16, true);
        writeString(36, 'data');
        view.setUint32(40, numSamples * 2, true);
        
        // Fill with silence (zeros)
        for (let i = 0; i < numSamples; i++) {
            view.setInt16(44 + i * 2, 0, true);
        }
        
        return new Blob([buffer], { type: 'audio/wav' });
    }
    
    function cleanupRecording() {
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            stream = null;
        }
        if (silenceTimer) {
            clearTimeout(silenceTimer);
            silenceTimer = null;
        }
    }
    
    function resetRecordingState() {
        isRecording = false;
        audioChunks = [];
        
        const recordBtn = document.getElementById('recordBtn');
        const stopBtn = document.getElementById('stopBtn');
        const recordingStatus = document.getElementById('recordingStatus');
        
        recordBtn.style.display = 'inline-block';
        stopBtn.style.display = 'none';
        recordingStatus.style.display = 'none';
    }

    async function stopRecording() {
        if (!isRecording || !mediaRecorder) {
            return;
        }
        
        console.log('Stopping recording...');
        isRecording = false;
        
        // Update UI immediately
        const recordingStatus = document.getElementById('recordingStatus');
        recordingStatus.innerHTML = '<i class="fas fa-circle-notch fa-spin"></i> جاري معالجة الصوت...';
        
        try {
            if (mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            }
        } catch (error) {
            console.error('Error stopping recorder:', error);
            // Force cleanup if stop fails
            cleanupRecording();
            resetRecordingState();
        }
    }

    async function sendAudioMessage(audioBlob) {
        if (!audioBlob || audioBlob.size < 10) { // Very small minimum size
            throw new Error('التسجيل قصير جداً أو به مشكلة. يرجى المحاولة مرة أخرى.');
        }
        
        console.log('Sending audio blob, size:', audioBlob.size, 'type:', audioBlob.type);

        const formData = new FormData();
        const fileExt = audioBlob.type.includes('wav') ? 'wav' : 'webm';
        const fileName = `recording_${Date.now()}.${fileExt}`;
        formData.append('audio', audioBlob, fileName);
        
        // Add language and other metadata
        formData.append('language', 'ar');
        formData.append('timestamp', new Date().toISOString());
        
        console.log('FormData created with file:', fileName, 'size:', audioBlob.size);

        // Create a unique ID for this message
        const messageId = 'msg-' + Date.now();
        
        // Show user that we're processing the audio
        addMessage('🎤 جاري معالجة التسجيل الصوتي...', true, messageId);
        showTypingIndicator();

        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 60000); // 60 second timeout

            // Get token from localStorage or global variable
            const token = localStorage.getItem('access_token') || window.token || '';
            console.log('Using token:', token ? 'Token exists' : 'No token found');
            
            const response = await fetch('/api/audio-chat', {
                method: 'POST',
                headers: {
                    'Authorization': 'Bearer ' + token
                },
                body: formData,
                signal: controller.signal
            });
            
            console.log('Response status:', response.status);
            console.log('Response headers:', Object.fromEntries(response.headers.entries()));

            clearTimeout(timeoutId);

            if (!response.ok) {
                const errorText = await response.text().catch(() => '');
                console.log('Error response text:', errorText);
                
                let errorData = {};
                try {
                    errorData = JSON.parse(errorText);
                } catch (e) {
                    console.warn('Could not parse error response as JSON');
                }
                
                throw new Error(errorData.error || `خطأ في الخادم: ${response.status} - ${errorText.substring(0, 100)}`);
            }

            const data = await response.json();
            
            // Update the message with the transcript
            updateMessage(messageId, `🎤 ${data.transcript || 'تم إرسال الرسالة الصوتية'}`, true);
            
            // Show the bot's response
            if (data.answer) {
                addMessage(data.answer, false);
            } else {
                addMessage('لم أتمكن من فهم السؤال. يرجى المحاولة مرة أخرى.', false);
            }
            
            return data;
            
        } catch (error) {
            console.error('Error sending audio:', error);
            
            let errorMessage = 'حدث خطأ في إرسال التسجيل الصوتي';
            if (error.name === 'AbortError') {
                errorMessage = 'انتهت مهلة الاتصال بالخادم. يرجى المحاولة مرة أخرى.';
            } else if (error.message) {
                errorMessage = error.message;
            }
            
            // Update the message with the error
            updateMessage(messageId, `❌ ${errorMessage}`, true);
            throw error;
            
        } finally {
            hideTypingIndicator();
        }
    }

    // Language helpers for base.html
    function translateToArabic() {
        try {
            const header = document.querySelector('.chat-header h4');
            const subtitle = document.querySelector('.chat-header p');
            const messageInput = document.getElementById('messageInput');
            const recordBtn = document.getElementById('recordBtn');
            const stopBtn = document.getElementById('stopBtn');
            
            if (header) header.innerHTML = '<i class="fas fa-comments me-2"></i>الشات بوت الذكي';
            if (subtitle) subtitle.textContent = 'اسأل أي سؤال عن جامعة باديا';
            if (messageInput) messageInput.placeholder = 'اكتب سؤالك عن جامعة باديا هنا...';
            if (recordBtn) recordBtn.innerHTML = '<i class="fas fa-microphone me-2"></i>اضغط للتسجيل الصوتي';
            if (stopBtn) stopBtn.innerHTML = '<i class="fas fa-stop me-2"></i>إيقاف التسجيل';
        } catch(e) { console.warn('translateToArabic failed', e); }
    }

    function translateToEnglish() {
        try {
            const header = document.querySelector('.chat-header h4');
            const subtitle = document.querySelector('.chat-header p');
            const messageInput = document.getElementById('messageInput');
            const recordBtn = document.getElementById('recordBtn');
            const stopBtn = document.getElementById('stopBtn');
            
            if (header) header.innerHTML = '<i class="fas fa-comments me-2"></i>Smart Chatbot';
            if (subtitle) subtitle.textContent = 'Ask any question about Badya University';
            if (messageInput) messageInput.placeholder = 'Type your question about Badya University here...';
            if (recordBtn) recordBtn.innerHTML = '<i class="fas fa-microphone me-2"></i>Press to Record';
            if (stopBtn) stopBtn.innerHTML = '<i class="fas fa-stop me-2"></i>Stop Recording';
        } catch(e) { console.warn('translateToEnglish failed', e); }
    }
</script>
{% endblock %}
