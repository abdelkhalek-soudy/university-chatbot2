{% extends "base.html" %}

{% block title %}Ø§Ù„Ø´Ø§Øª - Ø¬Ø§Ù…Ø¹Ø© Ø¨Ø§Ø¯ÙŠØ§{% endblock %}

{% block extra_css %}
<style>
    /* University Logo for chat page */
    .university-logo-chat {
        display: none;
    }

    
    /* Custom logo-based background */
    body {
        background: linear-gradient(135deg, #9370DB 0%, #808080 100%) !important;
        position: relative !important;
    }
    
    body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background-image: 
            radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
            radial-gradient(circle at 80% 80%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
            radial-gradient(circle at 40% 60%, rgba(255, 255, 255, 0.05) 0%, transparent 50%);
        z-index: -2;
        pointer-events: none;
    }
    
    body::after {
        display: none;
    }
    
    .chat-box {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .chat-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px;
        text-align: center;
    }
    
    .message {
        margin: 15px;
        padding: 12px 18px;
        border-radius: 18px;
        max-width: 80%;
        animation: fadeInUp 0.3s ease;
    }
    
    .user-message {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        margin-left: auto;
        text-align: right;
    }
    
    .bot-message {
        background: rgba(248, 249, 250, 0.9);
        color: #333;
        border: 1px solid rgba(0, 0, 0, 0.1);
    }
    
    @keyframes fadeInUp {
        from {
            opacity: 0;
            transform: translateY(20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    .chat-input {
        background: rgba(255, 255, 255, 0.9);
        backdrop-filter: blur(10px);
        padding: 20px;
        border-top: 1px solid rgba(0, 0, 0, 0.1);
    }
    
    .btn {
        border-radius: 12px;
        font-weight: 500;
        transition: all 0.3s ease;
    }
    
    .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }
    
    .form-control {
        border-radius: 12px;
        border: 1px solid rgba(0, 0, 0, 0.1);
        background: rgba(255, 255, 255, 0.9);
    }
    
    .form-control:focus {
        box-shadow: 0 0 0 0.2rem rgba(102, 126, 234, 0.25);
        border-color: #667eea;
    }
    
    /* Typing indicator animation */
    .typing-indicator {
        display: inline-flex;
        align-items: center;
        gap: 4px;
    }
    .typing-indicator span {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background-color: #999;
        animation: typing 1.4s infinite ease-in-out;
    }
    .typing-indicator span:nth-child(1) { animation-delay: -0.32s; }
    .typing-indicator span:nth-child(2) { animation-delay: -0.16s; }
    @keyframes typing {
        0%, 80%, 100% { transform: scale(0); opacity: 0.5; }
        40% { transform: scale(1); opacity: 1; }
    }
    
    /* Blinking animation for recording status */
    .blink { animation: blink 1s linear infinite; }
    @keyframes blink { 0%, 50% { opacity: 1; } 51%, 100% { opacity: 0; } }
</style>
{% endblock %}

{% block content %}

<div class="chat-container">
    <div class="chat-box">
        <div class="chat-header">
            <h4><i class="fas fa-comments me-2"></i>Ø§Ù„Ø´Ø§Øª Ø¨ÙˆØª Ø§Ù„Ø°ÙƒÙŠ</h4>
            <p class="mb-0">Ø§Ø³Ø£Ù„ Ø£ÙŠ Ø³Ø¤Ø§Ù„ Ø¹Ù† Ø¬Ø§Ù…Ø¹Ø© Ø¨Ø§Ø¯ÙŠØ§</p>
        </div>
        
        <div class="chat-messages" id="chatMessages">
            <div class="message bot-message">
                <i class="fas fa-robot me-2"></i>
                Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø¬Ø§Ù…Ø¹Ø© Ø¨Ø§Ø¯ÙŠØ§! ÙƒÙŠÙ ÙŠÙ…ÙƒÙ†Ù†ÙŠ Ù…Ø³Ø§Ø¹Ø¯ØªÙƒ Ø§Ù„ÙŠÙˆÙ…ØŸ
            </div>
        </div>
        
        <div class="chat-input">
            <div class="row g-2">
                <div class="col">
                    <input type="text" class="form-control" id="messageInput" placeholder="Ø§ÙƒØªØ¨ Ø±Ø³Ø§Ù„ØªÙƒ Ù‡Ù†Ø§..." onkeypress="handleKeyPress(event)">
                </div>
                <div class="col-auto">
                    <button class="btn btn-primary" onclick="sendMessage()">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
            
            <div class="row g-2 mt-2">
                <div class="col-6">
                    <button class="btn btn-outline-primary w-100" onclick="toggleFileUpload()">
                        <i class="fas fa-file-upload me-1"></i>
                        Ø±ÙØ¹ Ù…Ù„Ù
                    </button>
                </div>
                <div class="col-6">
                    <button class="btn btn-outline-primary w-100" onclick="toggleAudioRecord()">
                        <i class="fas fa-microphone me-1"></i>
                        ØªØ³Ø¬ÙŠÙ„ ØµÙˆØªÙŠ
                    </button>
                </div>
            </div>
            
            <!-- File Upload Section -->
            <div id="fileUploadSection" class="mt-3" style="display: none;">
                <div class="card">
                    <div class="card-body">
                        <h6 class="card-title">Ø±ÙØ¹ Ù…Ù„Ù Ù„Ù„ØªØ­Ù„ÙŠÙ„</h6>
                        <input type="file" class="form-control" id="fileInput" accept=".pdf,.docx,.rtf,.jpg,.jpeg,.png,.mp3,.wav,.webm">
                        <button class="btn btn-success mt-2" onclick="uploadFile()">
                            <i class="fas fa-upload me-1"></i>
                            ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ù„Ù
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Audio Recording Section -->
            <div id="audioRecordSection" class="mt-3" style="display: none;">
                <div class="card">
                    <div class="card-body">
                        <h6 class="card-title">Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØµÙˆØªÙŠ</h6>
                        <div class="mb-2">
                            <label for="micSelect" class="form-label">Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ†</label>
                            <div class="d-flex gap-2">
                                <select id="micSelect" class="form-select"></select>
                                <button type="button" id="refreshMics" class="btn btn-outline-secondary">ØªØ­Ø¯ÙŠØ«</button>
                        </div>
                        <div class="form-check form-switch mb-3">
                            <input class="form-check-input" type="checkbox" id="forceFallbackChk">
                            <label class="form-check-label" for="forceFallbackChk">Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø¨Ø¯ÙŠÙ„ (WAV) Ø¥Ø°Ø§ ÙØ´Ù„ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø¹Ø§Ø¯ÙŠ</label>
                        </div>
                        <div class="text-center">
                            <button id="recordBtn" class="btn btn-danger" onclick="toggleRecording()">
                                <i class="fas fa-microphone"></i>
                                Ø§Ø¨Ø¯Ø£ Ø§Ù„ØªØ³Ø¬ÙŠÙ„
                            </button>
                            <button id="stopBtn" class="btn btn-secondary" onclick="stopRecording()" style="display: none;">
                                <i class="fas fa-stop"></i>
                                Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ØªØ³Ø¬ÙŠÙ„
                            </button>
                        </div>
                        <div id="recordingStatus" class="mt-2 text-center" style="display: none;">
                            <span class="text-danger">
                                <i class="fas fa-circle blink"></i>
                                Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ³Ø¬ÙŠÙ„...
                            </span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    let mediaRecorder;
    let audioChunks = [];
    let isRecording = false;
    let recordStartTime = 0;
    // Fallback (WebAudio) variables
    let audioStream = null;
    let audioContext = null;
    let sourceNode = null;
    let processor = null;
    let pcmData = [];
    let pcmLength = 0;
    let useFallback = false;
    let dataReceived = false;

    function handleKeyPress(event) {
        if (event.key === 'Enter') {
            sendMessage();
        }
    }

    function addMessage(content, isUser = false) {
        const messagesContainer = document.getElementById('chatMessages');
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${isUser ? 'user-message' : 'bot-message'}`;
        
        if (isUser) {
            messageDiv.innerHTML = `<i class="fas fa-user me-2"></i>${content}`;
        } else {
            messageDiv.innerHTML = `<i class="fas fa-robot me-2"></i>${content}`;
        }
        
        messagesContainer.appendChild(messageDiv);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    // Language helpers used by base.html toggleLanguage()
    function translateToArabic() {
        try {
            const header = document.querySelector('.chat-header h4');
            const subtitle = document.querySelector('.chat-header p');
            const messageInput = document.getElementById('messageInput');
            const fileBtn = document.querySelector('.row.g-2.mt-2 .col-6:nth-child(1) button');
            const micBtn = document.querySelector('.row.g-2.mt-2 .col-6:nth-child(2) button');
            if (header) header.innerHTML = '<i class="fas fa-comments me-2"></i>Ø§Ù„Ø´Ø§Øª Ø¨ÙˆØª Ø§Ù„Ø°ÙƒÙŠ';
            if (subtitle) subtitle.textContent = 'Ø§Ø³Ø£Ù„ Ø£ÙŠ Ø³Ø¤Ø§Ù„ Ø¹Ù† Ø¬Ø§Ù…Ø¹Ø© Ø¨Ø§Ø¯ÙŠØ§';
            if (messageInput) messageInput.placeholder = 'Ø§ÙƒØªØ¨ Ø±Ø³Ø§Ù„ØªÙƒ Ù‡Ù†Ø§...';
            if (fileBtn) fileBtn.innerHTML = '<i class="fas fa-file-upload me-1"></i> Ø±ÙØ¹ Ù…Ù„Ù';
            if (micBtn) micBtn.innerHTML = '<i class="fas fa-microphone me-1"></i> ØªØ³Ø¬ÙŠÙ„ ØµÙˆØªÙŠ';
        } catch(e) { console.warn('translateToArabic failed', e); }
    }

    function translateToEnglish() {
        try {
            const header = document.querySelector('.chat-header h4');
            const subtitle = document.querySelector('.chat-header p');
            const messageInput = document.getElementById('messageInput');
            const fileBtn = document.querySelector('.row.g-2.mt-2 .col-6:nth-child(1) button');
            const micBtn = document.querySelector('.row.g-2.mt-2 .col-6:nth-child(2) button');
            if (header) header.innerHTML = '<i class="fas fa-comments me-2"></i>Smart Chatbot';
            if (subtitle) subtitle.textContent = 'Ask any question about Badya University';
            if (messageInput) messageInput.placeholder = 'Type your message here...';
            if (fileBtn) fileBtn.innerHTML = '<i class="fas fa-file-upload me-1"></i> Upload File';
            if (micBtn) micBtn.innerHTML = '<i class="fas fa-microphone me-1"></i> Voice Recording';
        } catch(e) { console.warn('translateToEnglish failed', e); }
    }

    function showTypingIndicator() {
        const messagesContainer = document.getElementById('chatMessages');
        const typingDiv = document.createElement('div');
        typingDiv.className = 'message bot-message';
        typingDiv.id = 'typingIndicator';
        typingDiv.innerHTML = `
            <i class="fas fa-robot me-2"></i>
            <div class="typing-indicator">
                <span></span>
                <span></span>
                <span></span>
            </div>
        `;
        messagesContainer.appendChild(typingDiv);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    function hideTypingIndicator() {
        const typingIndicator = document.getElementById('typingIndicator');
        if (typingIndicator) {
            typingIndicator.remove();
        }
    }

    async function sendMessage() {
        const messageInput = document.getElementById('messageInput');
        const message = messageInput.value.trim();
        
        if (!message) return;
        
        addMessage(message, true);
        messageInput.value = '';
        
        showTypingIndicator();
        
        try {
            const response = await apiCall('/api/chat', {
                method: 'POST',
                body: JSON.stringify({ message })
            });
            
            if (response) {
                const data = await response.json();
                hideTypingIndicator();
                
                if (response.ok) {
                    addMessage(data.answer);
                } else {
                    addMessage(data.error || 'Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„', false);
                }
            }
        } catch (error) {
            hideTypingIndicator();
            addMessage('Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø®Ø§Ø¯Ù…', false);
        }
    }

    function toggleFileUpload() {
        const section = document.getElementById('fileUploadSection');
        const audioSection = document.getElementById('audioRecordSection');
        audioSection.style.display = 'none';
        section.style.display = section.style.display === 'none' ? 'block' : 'none';
    }

    function toggleAudioRecord() {
        const section = document.getElementById('audioRecordSection');
        const fileSection = document.getElementById('fileUploadSection');
        fileSection.style.display = 'none';
        const willShow = section.style.display === 'none';
        section.style.display = willShow ? 'block' : 'none';
        if (willShow) {
            ensurePermissionAndList();
        }
    }

    async function uploadFile() {
        const fileInput = document.getElementById('fileInput');
        const file = fileInput.files[0];
        
        if (!file) {
            alert('ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ù…Ù„Ù Ø£ÙˆÙ„Ø§Ù‹');
            return;
        }
        
        const formData = new FormData();
        formData.append('file', file);
        
        addMessage(`ØªÙ… Ø±ÙØ¹ Ø§Ù„Ù…Ù„Ù: ${file.name}`, true);
        showTypingIndicator();
        
        try {
            const response = await fetch('/api/analyze', {
                method: 'POST',
                headers: {
                    'Authorization': 'Bearer ' + token
                },
                body: formData
            });
            
            const data = await response.json();
            hideTypingIndicator();
            
            if (response.ok) {
                addMessage(data.reply);
            } else {
                addMessage(data.error || 'Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ù„Ù');
            }
        } catch (error) {
            hideTypingIndicator();
            addMessage('Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø±ÙØ¹ Ø§Ù„Ù…Ù„Ù');
        }
        
        fileInput.value = '';
        toggleFileUpload();
    }

    async function toggleRecording() {
        if (!isRecording) {
            try {
                const micSelect = document.getElementById('micSelect');
                const forceFallback = document.getElementById('forceFallbackChk')?.checked;
                const selectedDeviceId = micSelect && micSelect.value ? micSelect.value : undefined;
                // Ù„Ùˆ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø¨Ø¯ÙŠÙ„ Ù…ÙØ¹Ù‘Ù„: Ø§Ø¨Ø¯Ø£ WebAudio Ù…Ø¨Ø§Ø´Ø±Ø©
                if (forceFallback) {
                    const testStream = await navigator.mediaDevices.getUserMedia({ audio: { deviceId: selectedDeviceId ? { exact: selectedDeviceId } : undefined } });
                    isRecording = true;
                    recordStartTime = Date.now();
                    startFallbackRecording(testStream);
                    document.getElementById('recordBtn').style.display = 'none';
                    document.getElementById('stopBtn').style.display = 'inline-block';
                    document.getElementById('recordingStatus').style.display = 'block';
                    return;
                }
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        ...(selectedDeviceId ? { deviceId: { exact: selectedDeviceId } } : {})
                    }
                });
                
                // Ø§Ø®ØªÙŠØ§Ø± Ù†ÙˆØ¹ Ù…Ø¯Ø¹ÙˆÙ… Ù„Ù€ MediaRecorder
                let mimeType = 'audio/webm;codecs=opus';
                if (window.MediaRecorder && !MediaRecorder.isTypeSupported(mimeType)) {
                    mimeType = 'audio/webm';
                    if (!MediaRecorder.isTypeSupported(mimeType)) {
                        mimeType = 'audio/ogg;codecs=opus';
                        if (!MediaRecorder.isTypeSupported(mimeType)) {
                            mimeType = 'audio/mp4';
                            if (!MediaRecorder.isTypeSupported(mimeType)) {
                                mimeType = '';
                            }
                        }
                    }
                }
                const options = mimeType ? { mimeType, audioBitsPerSecond: 128000 } : { audioBitsPerSecond: 128000 };
                
                mediaRecorder = new MediaRecorder(stream, options);
                audioStream = stream;
                audioChunks = [];
                dataReceived = false;
                
                mediaRecorder.ondataavailable = event => {
                    if (event && event.data && event.data.size > 0) {
                        dataReceived = true;
                    }
                    audioChunks.push(event.data);
                };
                
                mediaRecorder.onstop = async () => {
                    try {
                        if (useFallback) {
                            // ØªÙ… Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø¨Ø§Ù„ÙØ¹Ù„ Ø¥Ù„Ù‰ fallbackØŒ Ø³ÙŠØªÙ… Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ù…Ù† Ù‡Ù†Ø§Ùƒ
                            return;
                        }
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        console.log('Created audio blob:', audioBlob.size, 'bytes');
                        await sendAudioMessage(audioBlob);
                    } finally {
                        try { mediaRecorder.stream.getTracks().forEach(t => t.stop()); } catch(e) {}
                    }
                };
                
                mediaRecorder.start(1000); // ØªØ³Ø¬ÙŠÙ„ ÙƒÙ„ Ø«Ø§Ù†ÙŠØ©
                isRecording = true;
                recordStartTime = Date.now();
                // Ø¥Ø°Ø§ Ù„Ù… ØªØµÙ„ Ø£ÙŠ Ø¨ÙŠØ§Ù†Ø§Øª Ø®Ù„Ø§Ù„ 1.5Ø« Ù†ØªØ­ÙˆÙ„ Ù„ØªØ³Ø¬ÙŠÙ„ WAV Ø¹Ø¨Ø± WebAudio
                setTimeout(() => {
                    if (isRecording && !dataReceived) {
                        console.warn('No data from MediaRecorder, switching to WebAudio fallback');
                        try { mediaRecorder.stop(); } catch(e) {}
                        startFallbackRecording(stream);
                    }
                }, 1500);
                
                document.getElementById('recordBtn').style.display = 'none';
                document.getElementById('stopBtn').style.display = 'inline-block';
                document.getElementById('recordingStatus').style.display = 'block';
                
            } catch (error) {
                alert('Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ†');
            }
        }
    }

    // Start fallback recorder using WebAudio (WAV)
    function startFallbackRecording(stream) {
        useFallback = true;
        audioStream = stream;
        pcmData = [];
        pcmLength = 0;
        try {
            const ACtx = window.AudioContext || window.webkitAudioContext;
            audioContext = new ACtx();
            const setupNodes = () => {
                sourceNode = audioContext.createMediaStreamSource(stream);
                const bufferSize = 4096;
                processor = audioContext.createScriptProcessor(bufferSize, 1, 1);
                processor.onaudioprocess = (e) => {
                    const input = e.inputBuffer.getChannelData(0);
                    pcmData.push(new Float32Array(input));
                    pcmLength += input.length;
                };
                sourceNode.connect(processor);
                processor.connect(audioContext.destination);
                console.log('Fallback WebAudio recorder started');
            };
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(setupNodes).catch(err => {
                    console.warn('AudioContext resume failed:', err); setupNodes();
                });
            } else {
                setupNodes();
            }
        } catch (e) {
            console.error('Failed to start WebAudio fallback:', e);
            addMessage('âŒ ØªØ¹Ø°Ø± ØªØ´ØºÙŠÙ„ Ù…Ø³Ø¬Ù„ Ø§Ù„ØµÙˆØª Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ. ÙŠØ±Ø¬Ù‰ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…ØªØµÙØ­ Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…ØªØµÙØ­ Ø¢Ø®Ø±.', false);
        }
    }

    function cleanupFallbackNodes(stopTracks = false) {
        try { if (processor) { processor.disconnect(); processor.onaudioprocess = null; } } catch(e) {}
        try { if (sourceNode) { sourceNode.disconnect(); } } catch(e) {}
        try { if (audioContext) { audioContext.close(); } } catch(e) {}
        if (stopTracks && audioStream) {
            try { audioStream.getTracks().forEach(t => t.stop()); } catch(e) {}
        }
        processor = null; sourceNode = null; audioContext = null;
    }

    function stopFallbackAndCreateBlob() {
        try {
            if (processor) { try { processor.disconnect(); } catch(_e){} }
            if (sourceNode) { try { sourceNode.disconnect(); } catch(_e){} }
            if (audioContext) { try { audioContext.close(); } catch(_e){} }
        } catch(e) {}
        // Flatten
        const samples = new Float32Array(pcmLength);
        let offset = 0;
        for (let i = 0; i < pcmData.length; i++) {
            samples.set(pcmData[i], offset);
            offset += pcmData[i].length;
        }
        // Encode WAV (16-bit PCM, mono) with actual context sampleRate
        const targetRate = (audioContext && audioContext.sampleRate) ? audioContext.sampleRate : 44100;
        const wavBuffer = encodeWAV(samples, targetRate);
        const blob = new Blob([wavBuffer], { type: 'audio/wav' });
        console.log('Created WAV blob (fallback):', blob.size, 'bytes');
        return blob;
    }

    function encodeWAV(samples, sampleRate) {
        const bytesPerSample = 2;
        const blockAlign = bytesPerSample * 1; // mono
        const buffer = new ArrayBuffer(44 + samples.length * bytesPerSample);
        const view = new DataView(buffer);

        /* RIFF identifier */ writeString(view, 0, 'RIFF');
        /* RIFF chunk length */ view.setUint32(4, 36 + samples.length * bytesPerSample, true);
        /* RIFF type */ writeString(view, 8, 'WAVE');
        /* format chunk identifier */ writeString(view, 12, 'fmt ');
        /* format chunk length */ view.setUint32(16, 16, true);
        /* sample format (raw) */ view.setUint16(20, 1, true);
        /* channel count */ view.setUint16(22, 1, true);
        /* sample rate */ view.setUint32(24, sampleRate, true);
        /* byte rate (sample rate * block align) */ view.setUint32(28, sampleRate * blockAlign, true);
        /* block align (channel count * bytes per sample) */ view.setUint16(32, blockAlign, true);
        /* bits per sample */ view.setUint16(34, 8 * bytesPerSample, true);
        /* data chunk identifier */ writeString(view, 36, 'data');
        /* data chunk length */ view.setUint32(40, samples.length * bytesPerSample, true);
        // write PCM samples
        floatTo16BitPCM(view, 44, samples);
        return view.buffer;
    }

    function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
        }
    }

    function floatTo16BitPCM(view, offset, input) {
        for (let i = 0; i < input.length; i++, offset += 2) {
            let s = Math.max(-1, Math.min(1, input[i]));
            view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
        }
    }

    // Microphone device listing
    async function listMicrophones() {
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const mics = devices.filter(d => d.kind === 'audioinput');
            const sel = document.getElementById('micSelect');
            if (!sel) return;
            const current = sel.value;
            sel.innerHTML = '';
            mics.forEach((d, idx) => {
                const opt = document.createElement('option');
                opt.value = d.deviceId;
                opt.textContent = d.label || `Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ† ${idx+1}`;
                sel.appendChild(opt);
            });
            if (current && [...sel.options].some(o => o.value === current)) sel.value = current;
        } catch (e) { console.warn('enumerateDevices failed', e); }
    }

    async function ensurePermissionAndList() {
        try {
            const test = await navigator.mediaDevices.getUserMedia({ audio: true });
            test.getTracks().forEach(t => t.stop());
        } catch (e) { /* ignore */ }
        await listMicrophones();
    }

    document.addEventListener('DOMContentLoaded', () => {
        const refresh = document.getElementById('refreshMics');
        if (refresh) refresh.addEventListener('click', ensurePermissionAndList);
        ensurePermissionAndList();
    });

    function stopRecording() {
        if (!isRecording) return;
        const elapsed = Date.now() - recordStartTime;
        const updateUI = () => {
            const recordBtn = document.getElementById('recordBtn');
            const stopBtn = document.getElementById('stopBtn');
            const recordingStatus = document.getElementById('recordingStatus');
            if (recordBtn) recordBtn.style.display = 'inline-block';
            if (stopBtn) stopBtn.style.display = 'none';
            if (recordingStatus) recordingStatus.style.display = 'none';
        };
        const finalizeStop = () => {
            if (!dataReceived && !useFallback && audioStream) {
                console.warn('No MediaRecorder data captured; switching to WebAudio fallback before stopping');
                useFallback = true;
                startFallbackRecording(audioStream);
                // Ø§Ø¬Ù…Ø¹ Ø«Ø§Ù†ÙŠØ© ÙˆØ§Ø­Ø¯Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„
                setTimeout(() => {
                    isRecording = false;
                    const blob = stopFallbackAndCreateBlob();
                    updateUI();
                    sendAudioMessage(blob);
                    useFallback = false;
                    try { if (audioStream) audioStream.getTracks().forEach(t => t.stop()); } catch(e) {}
                }, 1200);
                return;
            }
            if (useFallback) {
                isRecording = false;
                const blob = stopFallbackAndCreateBlob();
                updateUI();
                sendAudioMessage(blob);
                useFallback = false;
                try { if (audioStream) audioStream.getTracks().forEach(t => t.stop()); } catch(e) {}
            } else if (mediaRecorder && mediaRecorder.state === 'recording') {
                try { mediaRecorder.requestData(); } catch(e) {}
                mediaRecorder.stop();
                isRecording = false;
                setTimeout(updateUI, 100);
            } else {
                isRecording = false;
                updateUI();
            }
        };
        if (elapsed < 1200) {
            const waitMs = 1200 - elapsed;
            console.log('Waiting', waitMs, 'ms to ensure minimum duration');
            setTimeout(finalizeStop, waitMs);
        } else {
            finalizeStop();
        }
    }

    async function sendAudioMessage(audioBlob) {
        const formData = new FormData();
        const type = audioBlob && audioBlob.type ? audioBlob.type : 'audio/webm';
        let ext = '.webm';
        if (type.includes('wav')) ext = '.wav';
        else if (type.includes('ogg')) ext = '.ogg';
        else if (type.includes('mp4') || type.includes('m4a')) ext = '.m4a';
        const fileName = `recording_${new Date().toISOString().replace(/[:.]/g, '-')}${ext}`;
        formData.append('audio', audioBlob, fileName);
        
        if (!audioBlob || audioBlob.size < 44) {
            addMessage('ğŸ”‡ Ù„Ù… ÙŠØªÙ… Ø§Ù„ØªÙ‚Ø§Ø· Ø£ÙŠ ØµÙˆØª. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ø¯Ø« Ø¨ÙˆØ¶ÙˆØ­ Ø«Ù… Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.', false);
            return;
        }
        
        console.log(`Sending audio: ${audioBlob.size} bytes, type=${type}`);
        addMessage('ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØµÙˆØªÙŠ', true);
        showTypingIndicator();
        
        try {
            const authToken = (typeof getToken === 'function') ? getToken() : (typeof token !== 'undefined' ? token : null);
            const response = await fetch('/api/audio-chat', {
                method: 'POST',
                headers: {
                    ...(authToken ? { 'Authorization': 'Bearer ' + authToken } : {})
                },
                body: formData
            });
            
            const data = await response.json();
            hideTypingIndicator();
            
            if (response.ok) {
                addMessage(`Ø§Ù„Ù†Øµ Ø§Ù„Ù…ÙØ±Øº: "${data.transcript}"`);
                addMessage(data.answer);
            } else {
                addMessage(data.error || 'Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØµÙˆØªÙŠ');
            }
        } catch (error) {
            hideTypingIndicator();
            addMessage('Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØµÙˆØªÙŠ');
        }
        
        toggleAudioRecord();
    }
</script>
{% endblock %}